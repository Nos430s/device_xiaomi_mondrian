
project device/qcom/sepolicy_vndr/
diff --git a/generic/vendor/common/location.te b/generic/vendor/common/location.te
index 1dff035c..7ba8f352 100644
--- a/generic/vendor/common/location.te
+++ b/generic/vendor/common/location.te
@@ -65,5 +65,5 @@ userdebug_or_eng(`
 
 dontaudit vendor_location kernel:system module_request;
 
-# xtra-daemon control
-get_prop(vendor_location, xtra_control_prop)
+## xtra-daemon control
+# get_prop(vendor_location, xtra_control_prop)

project external/avb/
diff --git a/avbtool.py b/avbtool.py
index 05dc72c..9f3370d 100755
--- a/avbtool.py
+++ b/avbtool.py
@@ -4058,7 +4058,7 @@ def calc_fec_data_size(image_size, num_roots):
     ValueError: If output from the 'fec' tool is invalid.
   """
   p = subprocess.Popen(
-      ['fec', '--print-fec-size', str(image_size), '--roots', str(num_roots)],
+      ['/home/develop/android/pe/out/host/linux-x86/bin/fec', '--print-fec-size', str(image_size), '--roots', str(num_roots)],
       stdout=subprocess.PIPE,
       stderr=subprocess.PIPE)
   (pout, perr) = p.communicate()
@@ -4084,7 +4084,7 @@ def generate_fec_data(image_filename, num_roots):
   with tempfile.NamedTemporaryFile() as fec_tmpfile:
     try:
       subprocess.check_call(
-          ['fec', '--encode', '--roots', str(num_roots), image_filename,
+          ['/home/develop/android/pe/out/host/linux-x86/bin/fec', '--encode', '--roots', str(num_roots), image_filename,
            fec_tmpfile.name],
           stderr=open(os.devnull, 'wb'))
     except subprocess.CalledProcessError as e:

project frameworks/av/
diff --git a/media/codec2/sfplugin/CCodec.cpp b/media/codec2/sfplugin/CCodec.cpp
index feb0876b18..63dcedb44f 100644
--- a/media/codec2/sfplugin/CCodec.cpp
+++ b/media/codec2/sfplugin/CCodec.cpp
@@ -18,6 +18,7 @@
 #define LOG_TAG "CCodec"
 #include <utils/Log.h>
 
+#include <fstream>
 #include <sstream>
 #include <thread>
 
@@ -68,6 +69,17 @@ typedef CCodecConfig Config;
 
 namespace {
 
+std::string getCurrentProcessName() {
+    std::ifstream file("/proc/self/cmdline");
+    if (file) {
+        std::string processName;
+        std::getline(file, processName, '\0');
+        file.close();
+        return processName;
+    }
+    return "";
+}
+
 class CCodecWatchdog : public AHandler {
 private:
     enum {
@@ -730,10 +742,20 @@ void CCodec::allocate(const sp<MediaCodecInfo> &codecInfo) {
         mCallback->onError(UNKNOWN_ERROR, ACTION_CODE_FATAL);
         return;
     }
-    ALOGD("allocate(%s)", codecInfo->getCodecName());
-    mClientListener.reset(new ClientListener(this));
-
+    
+    std::string processName = getCurrentProcessName();
     AString componentName = codecInfo->getCodecName();
+
+    // Fix issue for bilibili switch to background 
+    if (processName == "com.bilibili.app.in:ijkservice" || 
+        processName == "tv.danmaku.bili:ijkservice") {
+        if (componentName == "c2.qti.hevc.decoder.low_latency") {
+            componentName = "c2.qti.avc.decoder";
+        }
+    }
+
+    ALOGD("allocate(%s) %s", componentName.c_str(), processName.c_str());
+    mClientListener.reset(new ClientListener(this));
     std::shared_ptr<Codec2Client> client;
 
     // set up preferred component store to access vendor store parameters

project frameworks/base/
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index c18f75c41787..46f67c81bb29 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4597,6 +4597,36 @@ public final class Settings {
          */
         public static final int SCREEN_BRIGHTNESS_MODE_AUTOMATIC = 1;
 
+        /**
+         * Screen resolution mode.
+         *  0 = disable
+         *  1 = overlay size
+         * @hide
+         */
+        @Readable
+        public static final String SCREEN_RESOLUTION_MODE = "screen_resolution_mode";
+
+        /**
+         * Override resolution width.
+         * @hide
+         */
+        @Readable
+        public static final String SCREEN_OVERRIDE_WIDTH = "screen_override_width";
+
+        /**
+         * Override resolution height.
+         * @hide
+         */
+        @Readable
+        public static final String SCREEN_OVERRIDE_HEIGHT = "screen_override_height";
+
+        /**
+         * Override resolution density.
+         * @hide
+         */
+        @Readable
+        public static final String SCREEN_OVERRIDE_DENSITY = "screen_override_density";
+        
         /**
          * Control whether to enable adaptive sleep mode.
          * @deprecated Use {@link android.provider.Settings.Secure#ADAPTIVE_SLEEP} instead.
diff --git a/packages/SettingsLib/src/com/android/settingslib/display/DisplayDensityUtils.java b/packages/SettingsLib/src/com/android/settingslib/display/DisplayDensityUtils.java
index d4d2b48fcc04..300753f0d234 100644
--- a/packages/SettingsLib/src/com/android/settingslib/display/DisplayDensityUtils.java
+++ b/packages/SettingsLib/src/com/android/settingslib/display/DisplayDensityUtils.java
@@ -18,10 +18,12 @@ package com.android.settingslib.display;
 
 import android.content.Context;
 import android.content.res.Resources;
+import android.graphics.Point;
 import android.hardware.display.DisplayManager;
 import android.os.AsyncTask;
 import android.os.RemoteException;
 import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import android.util.MathUtils;
@@ -98,6 +100,7 @@ public class DisplayDensityUtils {
 
     private int mDefaultDensityForDefaultDisplay;
     private int mCurrentIndex = -1;
+    
 
     public DisplayDensityUtils(Context context) {
         this(context, INTERNAL_ONLY);
@@ -130,7 +133,7 @@ public class DisplayDensityUtils {
             }
 
             final int defaultDensity = DisplayDensityUtils.getDefaultDensityForDisplay(
-                    display.getDisplayId());
+                    context, display.getDisplayId());
             if (defaultDensity <= 0) {
                 Log.w(LOG_TAG, "Cannot fetch default density for display "
                         + display.getDisplayId());
@@ -246,12 +249,24 @@ public class DisplayDensityUtils {
      * @return the default density of the specified display, or {@code -1} if
      *         the display does not exist or the density could not be obtained
      */
-    private static int getDefaultDensityForDisplay(int displayId) {
+    private static int getDefaultDensityForDisplay(Context context, int displayId) {
        try {
-           final IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
-           return wm.getInitialDisplayDensity(displayId);
+            int overrideWidth = Settings.System.getIntForUser(context.getContentResolver(), 
+                Settings.System.SCREEN_OVERRIDE_WIDTH, 0, UserHandle.USER_CURRENT);
+            int overrideHeight = Settings.System.getIntForUser(context.getContentResolver(), 
+                Settings.System.SCREEN_OVERRIDE_HEIGHT, 0, UserHandle.USER_CURRENT);
+            int overrideDensity = Settings.System.getIntForUser(context.getContentResolver(), 
+                Settings.System.SCREEN_OVERRIDE_DENSITY, 0, UserHandle.USER_CURRENT);
+                
+            final IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
+            Point size = new Point();
+            wm.getBaseDisplaySize(displayId, size);
+            if (size.x == overrideWidth && size.y == overrideHeight && overrideDensity > 0) {
+                return overrideDensity;
+            }
+            return wm.getInitialDisplayDensity(displayId);
        } catch (RemoteException exc) {
-           return -1;
+            return -1;
        }
     }
 
diff --git a/packages/SettingsProvider/src/android/provider/settings/validators/SystemSettingsValidators.java b/packages/SettingsProvider/src/android/provider/settings/validators/SystemSettingsValidators.java
index b16a1088d5c1..c79981b73c47 100644
--- a/packages/SettingsProvider/src/android/provider/settings/validators/SystemSettingsValidators.java
+++ b/packages/SettingsProvider/src/android/provider/settings/validators/SystemSettingsValidators.java
@@ -113,6 +113,10 @@ public class SystemSettingsValidators {
         VALIDATORS.put(System.SCREEN_OFF_TIMEOUT, NON_NEGATIVE_INTEGER_VALIDATOR);
         VALIDATORS.put(System.SCREEN_BRIGHTNESS_FOR_VR, new InclusiveIntegerRangeValidator(0, 255));
         VALIDATORS.put(System.SCREEN_BRIGHTNESS_MODE, BOOLEAN_VALIDATOR);
+        VALIDATORS.put(System.SCREEN_RESOLUTION_MODE, NON_NEGATIVE_INTEGER_VALIDATOR);
+        VALIDATORS.put(System.SCREEN_OVERRIDE_WIDTH, NON_NEGATIVE_INTEGER_VALIDATOR);
+        VALIDATORS.put(System.SCREEN_OVERRIDE_HEIGHT, NON_NEGATIVE_INTEGER_VALIDATOR);
+        VALIDATORS.put(System.SCREEN_OVERRIDE_DENSITY, NON_NEGATIVE_INTEGER_VALIDATOR);
         VALIDATORS.put(System.ADAPTIVE_SLEEP, BOOLEAN_VALIDATOR);
         VALIDATORS.put(System.MODE_RINGER_STREAMS_AFFECTED, NON_NEGATIVE_INTEGER_VALIDATOR);
         VALIDATORS.put(System.MUTE_STREAMS_AFFECTED, NON_NEGATIVE_INTEGER_VALIDATOR);
diff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java
index 368da684f9f8..5c30a83e40d7 100644
--- a/services/core/java/com/android/server/wm/WindowManagerService.java
+++ b/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -361,6 +361,7 @@ public class WindowManagerService extends IWindowManager.Stub
     private static final int TRACE_MAX_SECTION_NAME_LENGTH = 127;
 
     static final int LAYOUT_REPEAT_THRESHOLD = 4;
+    static final int OVERRIDE_DEFAULT_DENSITY = 420;
 
     static final boolean PROFILE_ORIENTATION = false;
     static WindowState mFocusingWindow;
@@ -3658,6 +3659,11 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    private boolean isOverrideSize(DisplayContent displayContent) {
+        return (displayContent.mBaseDisplayWidth != displayContent.mInitialDisplayWidth || 
+            displayContent.mBaseDisplayHeight != displayContent.mInitialDisplayHeight);
+    }
+
     public void setCurrentUser(final int newUserId, final int[] currentProfileIds) {
         synchronized (mGlobalLock) {
             mCurrentUserId = newUserId;
@@ -3675,10 +3681,24 @@ public class WindowManagerService extends IWindowManager.Stub
             // If the display is already prepared, update the density.
             // Otherwise, we'll update it when it's prepared.
             if (mDisplayReady) {
+                int currentResolutionMode = isOverrideSize(displayContent) ? 1 : 0;
+                int resolutionMode = Settings.System.getIntForUser(mContext.getContentResolver(),
+                    Settings.System.SCREEN_RESOLUTION_MODE, 0, newUserId);
+                
+                final int initialDisplayDensity = isOverrideSize(displayContent) ? 
+                        OVERRIDE_DEFAULT_DENSITY : displayContent.mInitialDisplayDensity;
                 final int forcedDensity = getForcedDisplayDensityForUserLocked(newUserId);
                 final int targetDensity = forcedDensity != 0 ? forcedDensity
-                        : displayContent.mInitialDisplayDensity;
-                displayContent.setForcedDensity(targetDensity, UserHandle.USER_CURRENT);
+                        : initialDisplayDensity;
+
+                if (currentResolutionMode != resolutionMode) {
+                    Settings.System.putIntForUser(mContext.getContentResolver(),
+                            Settings.System.SCREEN_RESOLUTION_MODE, 
+                            currentResolutionMode, newUserId);
+                    displayContent.setForcedDensity(initialDisplayDensity, UserHandle.USER_CURRENT);
+                } else {
+                    displayContent.setForcedDensity(targetDensity, UserHandle.USER_CURRENT);
+                }                
             }
         }
     }
diff --git a/telecomm/java/android/telecom/Connection.java b/telecomm/java/android/telecom/Connection.java
index 49ad58550db8..dec6def806c6 100644
--- a/telecomm/java/android/telecom/Connection.java
+++ b/telecomm/java/android/telecom/Connection.java
@@ -896,6 +896,17 @@ public abstract class Connection extends Conferenceable {
      */
     public static final String EVENT_CALL_MERGE_FAILED = "android.telecom.event.CALL_MERGE_FAILED";
 
+    /**
+     * Connection event used to inform Telecom when a resume operation on a call has failed.
+     * This event is only sent when concurrent calls (DSDA) are possible
+     * <p>
+     * Sent via {@link #sendConnectionEvent(String, Bundle)}.  The {@link Bundle} parameter is
+     * expected to be null when this connection event is used.
+     * @hide
+     */
+    public static final String EVENT_CALL_RESUME_FAILED =
+            "android.telecom.event.CALL_RESUME_FAILED";
+
     /**
      * Connection event used to inform Telecom when a hold operation on a call has failed.
      * <p>
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index ecd8c7a3d917..a5af0093cb80 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -561,6 +561,35 @@ public class TelephonyManager {
         }
     }
 
+    /**
+     * The allowed values for multi sim voice capability
+     *
+     * @hide
+     */
+    public interface MultiSimVoiceCapability {
+        /** default */
+        static final int UNKNOWN = 0;
+        /** Concurrent calls on both subscriptions are not possbile. */
+        static final int DSDS = 1;
+        /** Concurrent calls on both subscriptions are not possible but user will have option to
+         * accept MT call on one subscription when there is an ongoing call on another subscription.
+         */
+        static final int PSEUDO_DSDA = 2;
+        /** Concurrent calls on both subscriptions are possible */
+        static final int DSDA = 3;
+    }
+
+    /**
+     * Returns true if concurrent calls on both subscriptions are possible (ex: DSDA).
+     * Returns false for other cases.
+     */
+    /** {@hide} */
+    public static boolean isConcurrentCallsPossible() {
+        int mSimVoiceConfig = TelephonyProperties.multi_sim_voice_capability().orElse(
+                MultiSimVoiceCapability.UNKNOWN);
+        return mSimVoiceConfig == MultiSimVoiceCapability.DSDA;
+    }    
+
     /**
      * Returns the number of phones available.
      * Returns 0 if none of voice, sms, data is not supported

project frameworks/native/
diff --git a/services/vibratorservice/VibratorHalController.cpp b/services/vibratorservice/VibratorHalController.cpp
index c1795f5c32..b32c85270b 100644
--- a/services/vibratorservice/VibratorHalController.cpp
+++ b/services/vibratorservice/VibratorHalController.cpp
@@ -53,7 +53,8 @@ std::shared_ptr<HalWrapper> connectHal(std::shared_ptr<CallbackScheduler> schedu
         return nullptr;
     }
 
-    sp<Aidl::IVibrator> aidlHal = waitForVintfService<Aidl::IVibrator>();
+    sp<Aidl::IVibrator> aidlHal = waitForVintfService<Aidl::IVibrator>(String16("vibratorfeature"));
+    //sp<Aidl::IVibrator> aidlHal = waitForVintfService<Aidl::IVibrator>();
     if (aidlHal) {
         ALOGV("Successfully connected to Vibrator HAL AIDL service.");
         return std::make_shared<AidlHalWrapper>(std::move(scheduler), aidlHal);

project hardware/custom/compat/
diff --git a/Android.bp b/Android.bp
index a13f929..81e5886 100644
--- a/Android.bp
+++ b/Android.bp
@@ -137,6 +137,13 @@ cc_library_shared {
     vendor_available: true,
 }
 
+cc_library_shared {
+    name: "android.hardware.power-V3-ndk_platform",
+    shared_libs: ["android.hardware.power-V3-ndk"],
+    system_ext_specific: true,
+    vendor_available: true,
+}
+
 cc_library_shared {
     name: "android.hardware.power.stats-V1-ndk_platform",
     shared_libs: ["android.hardware.power.stats-V1-ndk"],

project hardware/interfaces/
diff --git a/audio/common/all-versions/default/service/Android.bp b/audio/common/all-versions/default/service/Android.bp
index 9890be295..dc87ae9a0 100644
--- a/audio/common/all-versions/default/service/Android.bp
+++ b/audio/common/all-versions/default/service/Android.bp
@@ -64,8 +64,42 @@ cc_binary {
     ],
 }
 
+cc_binary {
+    name: "android.hardware.audio.service_64",
+
+    init_rc: ["android.hardware.audio.service_64.rc"],
+    relative_install_path: "hw",
+    vendor: true,
+    compile_multilib: "64",
+    srcs: ["service.cpp"],
+
+    cflags: [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ],
+
+    shared_libs: [
+        "libcutils",
+        "libbinder",
+        "libbinder_ndk",
+        "libhidlbase",
+        "liblog",
+        "libutils",
+        "libhardware",
+    ],
+
+    defaults: [
+        "android_hardware_audio_config_defaults",
+    ],
+}
+
 // Legacy service name, use android.hardware.audio.service instead
 phony {
     name: "android.hardware.audio@2.0-service",
     required: ["android.hardware.audio.service"],
 }
+phony {
+    name: "android.hardware.audio@2.0-service_64",
+    required: ["android.hardware.audio.service_64"],
+}
\ No newline at end of file

project hardware/qcom-caf/sm8450/audio/pal/
diff --git a/Android.mk b/Android.mk
index 507af7d6..9b552ce0 100644
--- a/Android.mk
+++ b/Android.mk
@@ -179,6 +179,7 @@ LOCAL_USE_VNDK := true
 
 LOCAL_C_INCLUDES     := $(call project-path-for,qcom-audio)/pal
 
+LOCAL_CFLAGS += -Wall -Wno-error -Wno-unused-function -Wno-unused-variable
 LOCAL_CFLAGS += -Wno-tautological-compare
 LOCAL_CFLAGS += -Wno-macro-redefined
 

project hardware/qcom-caf/sm8450/display/
diff: [Errno 2] No such file or directory: '/home/develop/android/pe/hardware/qcom-caf/sm8450/display'

project packages/apps/Settings/
diff --git a/src/com/android/settings/accessibility/DisplaySizeData.java b/src/com/android/settings/accessibility/DisplaySizeData.java
index 77ae897708..5d75bba0b7 100644
--- a/src/com/android/settings/accessibility/DisplaySizeData.java
+++ b/src/com/android/settings/accessibility/DisplaySizeData.java
@@ -56,10 +56,11 @@ class DisplaySizeData extends PreviewSizeData<Integer> {
     @Override
     void commit(int currentProgress) {
         final int densityDpi = getValues().get(currentProgress);
-        if (densityDpi == getDefaultValue()) {
-            mDensity.clearForcedDisplayDensity();
-        } else {
-            mDensity.setForcedDisplayDensity(currentProgress);
-        }
+        mDensity.setForcedDisplayDensity(currentProgress);
+        // if (densityDpi == getDefaultValue()) {
+        //     mDensity.clearForcedDisplayDensity();
+        // } else {
+        //     mDensity.setForcedDisplayDensity(currentProgress);
+        // }
     }
 }

project packages/modules/Bluetooth/
diff --git a/android/app/src/com/android/bluetooth/hfp/HeadsetService.java b/android/app/src/com/android/bluetooth/hfp/HeadsetService.java
index 856f7dde04..90309cc39b 100644
--- a/android/app/src/com/android/bluetooth/hfp/HeadsetService.java
+++ b/android/app/src/com/android/bluetooth/hfp/HeadsetService.java
@@ -946,6 +946,16 @@ public class HeadsetService extends ProfileService {
                 receiver.propagateException(e);
             }
         }
+
+        @Override
+        public void phoneStateChangedDsDa(int numActive, int numHeld, int callState, String number,
+                                          int type, String name, AttributionSource source) {
+        }
+
+        @Override
+        public void clccResponseDsDa(int index, int direction, int status, int mode, boolean mpty,
+                                     String number, int type, AttributionSource source) {
+        }
     }
 
     // API methods
diff --git a/framework/java/android/bluetooth/BluetoothHeadset.java b/framework/java/android/bluetooth/BluetoothHeadset.java
index 403a8a8ec1..0c63950361 100644
--- a/framework/java/android/bluetooth/BluetoothHeadset.java
+++ b/framework/java/android/bluetooth/BluetoothHeadset.java
@@ -1427,4 +1427,59 @@ public final class BluetoothHeadset implements BluetoothProfile {
     private static void log(String msg) {
         Log.d(TAG, msg);
     }
+
+     /**
+     * Notify Headset of phone state change.
+     * This is a backdoor for phone app to call BluetoothHeadset since
+     * there is currently not a good way to get precise call state change outside
+     * of phone app.
+     *
+     * @hide
+     */
+    @RequiresBluetoothConnectPermission
+    @RequiresPermission(allOf = {
+            android.Manifest.permission.BLUETOOTH_CONNECT,
+            android.Manifest.permission.MODIFY_PHONE_STATE,
+    })
+    public void phoneStateChangedDsDa(int numActive, int numHeld, int callState, String number,
+            int type, String name) {
+        final IBluetoothHeadset service = getService();
+        if (service != null && isEnabled()) {
+            try {
+                service.phoneStateChangedDsDa(numActive, numHeld, callState, number, type, name,
+                        mAttributionSource);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+    }
+
+    /**
+     * Send Headset of CLCC response
+     *
+     * @hide
+     */
+    @RequiresBluetoothConnectPermission
+    @RequiresPermission(allOf = {
+            android.Manifest.permission.BLUETOOTH_CONNECT,
+            android.Manifest.permission.MODIFY_PHONE_STATE,
+    })
+    public void clccResponseDsDa(int index, int direction, int status, int mode, boolean mpty,
+            String number, int type) {
+        final IBluetoothHeadset service = getService();
+        if (service != null && isEnabled()) {
+            try {
+                service.clccResponseDsDa(index, direction, status, mode, mpty, number, type,
+                        mAttributionSource);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        } else {
+            Log.w(TAG, "Proxy not attached to service");
+            if (DBG) Log.d(TAG, Log.getStackTraceString(new Throwable()));
+        }
+    }
 }
diff --git a/system/audio_hal_interface/hidl/codec_status_hidl.cc b/system/audio_hal_interface/hidl/codec_status_hidl.cc
index 3a1db42326..11f892d7b9 100644
--- a/system/audio_hal_interface/hidl/codec_status_hidl.cc
+++ b/system/audio_hal_interface/hidl/codec_status_hidl.cc
@@ -494,6 +494,16 @@ bool UpdateOffloadingCapabilities(
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_type_masks |= CodecType::LDAC;
         break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LC3:
+        LOG(WARNING) << __func__
+                     << ": Ignore source codec_type=" << preference.codec_type
+                     << ", not supported on HIDL";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_OPUS:
+        LOG(WARNING) << __func__
+                     << ": Ignore source codec_type=" << preference.codec_type
+                     << ", not supported on HIDL";
+        break;
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         [[fallthrough]];
       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
diff --git a/system/binder/android/bluetooth/IBluetoothHeadset.aidl b/system/binder/android/bluetooth/IBluetoothHeadset.aidl
index 3e9474c99a..4b32456184 100644
--- a/system/binder/android/bluetooth/IBluetoothHeadset.aidl
+++ b/system/binder/android/bluetooth/IBluetoothHeadset.aidl
@@ -101,4 +101,8 @@ interface IBluetoothHeadset {
     oneway void isNoiseReductionSupported(in BluetoothDevice device, in AttributionSource attributionSource, in SynchronousResultReceiver receiver);
     @JavaPassthrough(annotation="@android.annotation.RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)")
     oneway void isVoiceRecognitionSupported(in BluetoothDevice device, in AttributionSource attributionSource, in SynchronousResultReceiver receiver);
+    @JavaPassthrough(annotation="@android.annotation.RequiresPermission(allOf={android.Manifest.permission.BLUETOOTH_CONNECT,android.Manifest.permission.MODIFY_PHONE_STATE})")
+    oneway void phoneStateChangedDsDa(int numActive, int numHeld, int callState, String number, int type, String name, in AttributionSource attributionSource);
+    @JavaPassthrough(annotation="@android.annotation.RequiresPermission(allOf={android.Manifest.permission.BLUETOOTH_CONNECT,android.Manifest.permission.MODIFY_PHONE_STATE})")
+    void clccResponseDsDa(int index, int direction, int status, int mode, boolean mpty, String number, int type, in AttributionSource attributionSource);
 }

project system/libsysprop/
diff --git a/srcs/android/sysprop/TelephonyProperties.sysprop b/srcs/android/sysprop/TelephonyProperties.sysprop
index 15999e7..eb64ff5 100644
--- a/srcs/android/sysprop/TelephonyProperties.sysprop
+++ b/srcs/android/sysprop/TelephonyProperties.sysprop
@@ -468,3 +468,15 @@ prop {
     access: Readonly
     prop_name: "ro.telephony.sim_slots.count"
 }
+
+#
+# System property which is used to store multi sim voice capability.
+# Possible values {@link TelephonyManager#MultiSimVoiceCapability}.
+#
+prop {
+    api_name: "multi_sim_voice_capability"
+    type: Integer
+    scope: Internal
+    access: ReadWrite
+    prop_name: "ril.multisim.voice_capability"
+}
\ No newline at end of file
